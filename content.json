{"pages":[{"title":"哈哈，这就是我","text":"教育背景： 普本+211硕 获得荣誉： 全国大学生英语竞赛国家二等奖 高教社杯数学建模竞赛省级二等奖 美国大学生竞赛H奖 蓝桥杯个人小组赛省二 证书： 英语六级 全国计算机等级考试二、三、四级 高级电子工程师 兴趣爱好： 跑步，很喜欢，让我瘦了20斤，哈哈 看书，各种看，文学，科幻，悬疑等 热闹安静的事情都喜欢 自我评价： 学编程，不是热爱，而是：一不讨厌，二钱多(这年头找一个符合这两个条件的工作还是比较难的) 周边的人都很乐观，我也算乐观吧 喜欢探索新鲜事物，但不喜欢无脑专研 人嘛总得培养点吃喝拉撒的坏毛病,要喜欢吃,也算是对生活的一种热爱 在人际方面感觉比别人少根筋,可能是社会历练不够，总抱着一种孤芳自赏的态度去对待学习和生活肯定是不行的,放低姿态吧，这样才能走的更远","link":"/about/index.html"}],"posts":[{"title":"30.Substring With Concatenation of All Words(续)","text":"题目描述：与所有单词相关联的子串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个子串s和一些长度相同的单词组成的字符串数组words.注意：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在s中找出恰好串联words中所有单词的子串的起始位置,中间不能有其他字符，但不要考虑words中单词串联的顺序.上篇我们讨论了本题的一种暴力求解法，本篇接着讨论另外两种优化的解法. 解法二：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本方法遍历子串时，同解法一不同之处在于，子串与给定单词字符串数组words的匹配规则不同.解法一是利用子串组成的数组和给定words的排序结果的内容相同来判断子串是否满足要求;而解法二利用了map，首先将words中单词与单词频次转化为key-value的形式，遍历s时得到的子串按同理存于另一个map里面，判断这两个map是否相等，以此决定该子串是否满足要求。 java源程序：1234567891011121314151617181920212223242526272829class Solution { public List&lt;Integer&gt; findSubstring(String s, String[] words) { int sLen = s.length(); int unit = words.length; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(unit==0 || sLen==0) return res; int wLen = words[0].length(); int wordsLen = unit*wLen; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); for(String word:words){ map.put(word,map.getOrDefault(word,0)+1); } for(int i=0;i&lt;sLen-wordsLen+1;i++){ Map&lt;String,Integer&gt; temp = new HashMap&lt;&gt;(map); int j=0; for(;j&lt;unit;j++){ String sub = s.substring(i+j*wLen,i+(j+1)*wLen); if(!temp.containsKey(sub)||temp.get(sub)==0) break; temp.put(sub,temp.get(sub)-1); } if(j==unit) res.add(i); } }} 运行时间和空间如下图： 解法三：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解法三与解法二判断子串和words是否匹配的方法一样，但是遍历子串的方式有所不同.在第一层循环中，以一个字符为单位，遍历次数为wLen,在第二层循环中，以wLen为一单位，比较当前子串第一个长度为wLen的单词与其后长度为wLen的单词是否相同，相同就维持未来字符串不变，这样，如果匹配成功的话，索引位置就对应于子串首次出现的位置;如果不同，删除子串第一个单词，加入子串后的一个单词，形成一个新的子串.两层循环下，可以将所有的情况遍历完，重要的是，第二层循环的处理减少了map的频繁操作，从而降低了时间的复杂度。 java源程序：123456789101112131415161718192021222324252627282930313233class Solution { public List&lt;Integer&gt; findSubstring(String s, String[] words) { int sLen = s.length(); int unit = words.length; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(unit==0 || sLen==0) return res; int wLen = words[0].length(); int wordsLen = unit*wLen; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); for(String word:words){ map.put(word,map.getOrDefault(word,0)+1); } for(int i=0;i&lt;wLen;i++){ Map&lt;String,Integer&gt; temp = new HashMap&lt;&gt;(); for(int k=0;k&lt;unit&amp;&amp;i+(k+1)*wLen&lt;=sLen;k++){ String sub = s.substring(i+k*wLen,i+(k+1)*wLen); temp.put(sub,temp.getOrDefault(sub,0)+1); } if(map.equals(temp)) res.add(i); for(int j=i+wordsLen;j+wLen&lt;=sLen;j+=wLen){ String start = s.substring(i,i+wLen); String end = s.substring(j,j+wLen); temp.put(end,temp.getOrDefault(end,0)+1); if(temp.get(start)==1) temp.remove(start); else temp.put(start,temp.get(start)-1); i += wLen; if(map.equals(temp)) res.add(i); } i%=wLen; } return res; } } 运行时间和空间如下图：","link":"/2019/04/03/与所有单词相关联的子串(续)/"},{"title":"30.Substring With Concatenation of All Words","text":"题目描述：与所有单词相关联的子串给定一个子串s和一些长度相同的单词组成的字符串数组words.注意：在s中找出恰好串联words中所有单词的子串的起始位置,中间不能有其他字符，但不要考虑words中单词串联的顺序. 示例1：(允许无序) Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = “barfoothefoobarman”,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;words = [“foo”,”bar”]Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,9] 示例2：(中间不能有其他字符) Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = “wordgoodgoodgoodbestword”,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;words = [“word”,”good”,”best”,”word”]Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[] 示例3：Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = “oooooo”,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;words = [“oo”,”oo”]Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,1,2] 由题意，我们可以得到以下几点信息： 找到的子串长度等于给定单词数组长度与其中单个字符串长度的乘积 单词数组里面允许出现重复的单词 子串之间是可以叠加出现的（示例3） 解法一： 首先，我们可以得到words中单个字符的长度，设为wLen,words字符串数组的长度为wordsLen; 找到的子串长度必定为wLen * wordsLen; 遍历给定字符串,长度为sLen,可以得到sLen-wLen * wordsLen+1个子串; 遍历时，将长度为wLen * wordsLen的子串等均等拆分为字符串数组,每个字符串长度为wLen; 将上一步得到的字符串数组进行排序，给定的words也要进行排序，这时候，如果两个字符串数组的内容一样，则该子串符合要求，将子串对应的索引添加到返回的结果数组中. java源程序：12345678910111213141516171819202122232425262728class Solution { public List&lt;Integer&gt; findSubstring(String s, String[] words) { int sLen = s.length(); int unit = words.length; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(unit==0 || sLen==0) return res; int wLen = words[0].length(); int wordsLen = unit*wLen; Arrays.sort(words); for(int i=0;i&lt;sLen-wordsLen+1;i++){ String sub = s.substring(i,i+wordsLen); if(isSubstring(sub,unit,wLen,words)){ res.add(i); } } return res; } public boolean isSubstring(String sub,int unit,int wLen,String[] words){ String[] temp = new String[unit]; for(int i=0,k=0;i&lt;unit;i++){ temp[i] = sub.substring(k,k+wLen); k = k+wLen; } Arrays.sort(temp); return Arrays.equals(temp,words); }} 当然，这样的算法属于一种暴力求解，复杂度最佳和最差都是n * log2(n)如下图：","link":"/2019/04/02/与所有单词相关联的子串/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"}]}