{"pages":[{"title":"哈哈，这就是我","text":"教育背景 普本+211硕 获得荣誉 全国大学生英语竞赛国家二等奖 高教社杯数学建模竞赛省级二等奖 美国大学生竞赛H奖 蓝桥杯个人小组赛省二 个人证书 英语六级 全国计算机等级考试二、三、四级 高级电子工程师 兴趣爱好 跑步，很喜欢，让我瘦了20斤，哈哈 看书，各种看，文学，科幻，悬疑等 热闹安静的事情都喜欢 自我评价 学编程，不是热爱，而是：一不讨厌，二钱多(这年头找一个符合这两个条件的工作还是比较难的) 周边的人都很乐观，我也算乐观吧 喜欢探索新鲜事物，但不喜欢无脑专研 人嘛总得培养点吃喝拉撒的坏毛病,要喜欢吃,也算是对生活的一种热爱 在人际方面感觉比别人少根筋,可能是社会历练不够，总抱着一种孤芳自赏的态度去对待学习和生活肯定是不行的,放低姿态吧，这样才能走的更远 Hello World","link":"/about/index.html"}],"posts":[{"title":"","text":"","link":"/2019/04/11/通配符匹配/"},{"title":"深入理解Java虚拟机","text":"jvm的内存模型运行时数据虚拟机栈 方法区","link":"/2019/04/06/我的第一篇篇博客/"},{"title":"32. Longest Valid Parentheses","text":"题目描述：最长有效括号给定一个只包含(和)的字符串，找出最长的包含有效的子串的长度。示例1： Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”(()”Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 示例2： Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;””)()())””Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 分析： 有效的括号是指任何可以连续可以成对的括号组成的字符串，例如()()(),((())),()(()())等等均为有效的括号 遇到类似成对消除的题目，首先就应该考虑到用栈这种数据结构来解决问题 思路：既然使用栈来解决这样的问题，那如何记录有效括号的长度呢？为了说得更明白一点，下面以输入字符串为()((()())(为例子。 # ( ) ( ( ( ) ( ) ) ( -1 0 1 2 3 4 5 6 7 8 9 首先，可以明确一点的是，用栈可以去消除有效的括号消除方法：遍历给定字符串，当满足栈顶元素为(并当前字符为)时，弹出栈顶元素；其他情况时，当前字符入栈；完成此操作后，栈中元素只剩下字符串中-1,2,9对应的字符，如下表： # ( ( -1 0 1 2 3 4 5 6 7 8 9 上一步仅仅是消除有效的括号，但是如何和本题求最长有效括号联系在一起呢？其实可以这样想，当我们消除掉有效括号后，栈中剩下的元素包含了有效括号的前面和后面的元素，有效括号前面一个和后面一个元素之间的距离不就是有效括号的长度吗？在这里，就对应于上表 的1-(-1)和8-2,这些长度里面最大的就是要求最长有效括号的长度，即8-2=6 因此，在栈中不仅要存遍历的当前字符，还要存放当前字符对应的索引位置，可以考虑在栈中放一个数组，数组第一个元素为(或),第二个元素为当前字符对应的索引。 总结： 初始化栈，栈中数组第一个元素随便放，第二个放入-1 遍历给定字符串 判断栈顶元素为(并当前字符为)时，弹出栈顶元素，这时候栈顶元素就变成了有效字符串前一个字符了，此时遍历的索引值减去当前栈顶元素对应的索引，每次这样得到的差值求个最大值，此时对应的最大差值即最长有效括号的长度。 算法的时间复杂度为n以下演示遍历过程：i=0 s.charAt(i) # ( ) ( ( ( ) ( ) ) ( i -1 0 1 2 3 4 5 6 7 8 9 此时，栈中元素状态： arr[0] # arr[1] -1 不满足栈顶元素为(,当前遍历元素为),当前遍历元素和对应索引入栈：栈中元素状态为： arr[0] # ( arr[1] -1 0 i=1 时,满足括号消除条件：栈中元素状态为： arr[0] # arr[1] -1 max = i-(-1)=2……以此类推,每次栈弹出时,栈顶元素对应的都是有效括号的前一个元素，同时更新max,最终遍历完字符串得到的max即为要返回的结果。若是理解不够清楚，读者可以自己尝试。 代码如下：123456789101112131415161718class Solution { public int longestValidParentheses(String s) { Stack&lt;int[]&gt; stack = new Stack&lt;&gt;(); stack.push(new int[]{0,-1}); int max = 0,cnt = 0; for(int i=0;i&lt;s.length();i++){ int temp = s.charAt(i); if(!stack.isEmpty() &amp;&amp; stack.peek()[0]==40 &amp;&amp; temp==41){ stack.pop(); cnt = i-stack.peek()[1]; if(cnt&gt;max) max=cnt; }else{ stack.push(new int[]{temp,i}); } } return max; }} 该解法运行结果对应的时间和空间复杂度如下图：要注意的问题：栈中放入的是整型数组，因此遍历得到的字符要转换为整型(对应于temp的自动类型转换)，(的整型值对应于40，)的整型值对应于41，当然，若是不知道他们对应的整型值，也可以用字符去判断，但在push到栈中时，要对temp进行强制类型转换。","link":"/2019/04/05/最长有效括号/"},{"title":"30.Substring With Concatenation of All Words","text":"题目描述：与所有单词相关联的子串给定一个子串s和一些长度相同的单词组成的字符串数组words.注意：在s中找出恰好串联words中所有单词的子串的起始位置,中间不能有其他字符，但不要考虑words中单词串联的顺序. 示例1：(允许无序) Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = “barfoothefoobarman”,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;words = [“foo”,”bar”]Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,9] 示例2：(中间不能有其他字符) Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = “wordgoodgoodgoodbestword”,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;words = [“word”,”good”,”best”,”word”]Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[] 示例3：Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = “oooooo”,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;words = [“oo”,”oo”]Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,1,2] 由题意，我们可以得到以下几点信息： 找到的子串长度等于给定单词数组长度与其中单个字符串长度的乘积 单词数组里面允许出现重复的单词 子串之间是可以叠加出现的（示例3） 解法一： 首先，我们可以得到words中单个字符的长度，设为wLen,words字符串数组的长度为wordsLen; 找到的子串长度必定为wLen * wordsLen; 遍历给定字符串,长度为sLen,可以得到sLen-wLen * wordsLen+1个子串; 遍历时，将长度为wLen * wordsLen的子串等均等拆分为字符串数组,每个字符串长度为wLen; 将上一步得到的字符串数组进行排序，给定的words也要进行排序，这时候，如果两个字符串数组的内容一样，则该子串符合要求，将子串对应的索引添加到返回的结果数组中. java源程序：12345678910111213141516171819202122232425262728class Solution { public List&lt;Integer&gt; findSubstring(String s, String[] words) { int sLen = s.length(); int unit = words.length; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(unit==0 || sLen==0) return res; int wLen = words[0].length(); int wordsLen = unit*wLen; Arrays.sort(words); for(int i=0;i&lt;sLen-wordsLen+1;i++){ String sub = s.substring(i,i+wordsLen); if(isSubstring(sub,unit,wLen,words)){ res.add(i); } } return res; } public boolean isSubstring(String sub,int unit,int wLen,String[] words){ String[] temp = new String[unit]; for(int i=0,k=0;i&lt;unit;i++){ temp[i] = sub.substring(k,k+wLen); k = k+wLen; } Arrays.sort(temp); return Arrays.equals(temp,words); }} 当然，这样的算法属于一种暴力求解，复杂度最佳和最差都是n * log2(n)如下图：","link":"/2019/04/02/与所有单词相关联的子串/"},{"title":"30.Substring With Concatenation of All Words(续)","text":"题目描述：与所有单词相关联的子串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个子串s和一些长度相同的单词组成的字符串数组words.注意：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在s中找出恰好串联words中所有单词的子串的起始位置,中间不能有其他字符，但不要考虑words中单词串联的顺序.上篇我们讨论了本题的一种暴力求解法，本篇接着讨论另外两种优化的解法. 解法二：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本方法遍历子串时，同解法一不同之处在于，子串与给定单词字符串数组words的匹配规则不同.解法一是利用子串组成的数组和给定words的排序结果的内容相同来判断子串是否满足要求;而解法二利用了map，首先将words中单词与单词频次转化为key-value的形式，遍历s时得到的子串按同理存于另一个map里面，判断这两个map是否相等，以此决定该子串是否满足要求。 java源程序：1234567891011121314151617181920212223242526272829class Solution { public List&lt;Integer&gt; findSubstring(String s, String[] words) { int sLen = s.length(); int unit = words.length; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(unit==0 || sLen==0) return res; int wLen = words[0].length(); int wordsLen = unit*wLen; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); for(String word:words){ map.put(word,map.getOrDefault(word,0)+1); } for(int i=0;i&lt;sLen-wordsLen+1;i++){ Map&lt;String,Integer&gt; temp = new HashMap&lt;&gt;(map); int j=0; for(;j&lt;unit;j++){ String sub = s.substring(i+j*wLen,i+(j+1)*wLen); if(!temp.containsKey(sub)||temp.get(sub)==0) break; temp.put(sub,temp.get(sub)-1); } if(j==unit) res.add(i); } }} 运行时间和空间如下图： 解法三：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解法三与解法二判断子串和words是否匹配的方法一样，但是遍历子串的方式有所不同.在第一层循环中，以一个字符为单位，遍历次数为wLen,在第二层循环中，以wLen为一单位，比较当前子串第一个长度为wLen的单词与其后长度为wLen的单词是否相同，相同就维持未来字符串不变，这样，如果匹配成功的话，索引位置就对应于子串首次出现的位置;如果不同，删除子串第一个单词，加入子串后的一个单词，形成一个新的子串.两层循环下，可以将所有的情况遍历完，重要的是，第二层循环的处理减少了map的频繁操作，从而降低了时间的复杂度。 java源程序：123456789101112131415161718192021222324252627282930313233class Solution { public List&lt;Integer&gt; findSubstring(String s, String[] words) { int sLen = s.length(); int unit = words.length; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(unit==0 || sLen==0) return res; int wLen = words[0].length(); int wordsLen = unit*wLen; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); for(String word:words){ map.put(word,map.getOrDefault(word,0)+1); } for(int i=0;i&lt;wLen;i++){ Map&lt;String,Integer&gt; temp = new HashMap&lt;&gt;(); for(int k=0;k&lt;unit&amp;&amp;i+(k+1)*wLen&lt;=sLen;k++){ String sub = s.substring(i+k*wLen,i+(k+1)*wLen); temp.put(sub,temp.getOrDefault(sub,0)+1); } if(map.equals(temp)) res.add(i); for(int j=i+wordsLen;j+wLen&lt;=sLen;j+=wLen){ String start = s.substring(i,i+wLen); String end = s.substring(j,j+wLen); temp.put(end,temp.getOrDefault(end,0)+1); if(temp.get(start)==1) temp.remove(start); else temp.put(start,temp.get(start)-1); i += wLen; if(map.equals(temp)) res.add(i); } i%=wLen; } return res; } } 运行时间和空间如下图：","link":"/2019/04/03/与所有单词相关联的子串(续)/"},{"title":"38. Count and Say","text":"题目描述：报数报数序列是指一个整数序列，按照顺序进行报数，得到下一个数。其中前五项如下： 1.1 读作一一,所以下一项为112.11读作二一,所以下一项为213.21读作一二一一,所以下一项为12114.1211读作一一一二二一,所以下一项为1112215.111221 读作三一二二一一,所以下一项为312211… 以此类推示例1： Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”1” 示例2： Input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4Output:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”1211” 分析： 报数是指一串序列中的某个数 该序列中某项的值与其前一项有关，规则如题目描述 思路：该序列中的某个值是由前一项的报数,因此具有这种回溯性质的题目，我们不妨可以采用递归的方法去做。写递归要明确两点：终止条件和递归体 终止条件：当n&lt;=1时,返回1; 递归体：在假定得到前一项的值后，需要对该值进行遍历，遍历时要统计连续相同字符的长度，以该数个数+该数组成新的字符串，便可得到报数。 java代码：12345678910111213141516class Solution { public String countAndSay(int n) { if(n&lt;=1) return \"1\"; String preStr = countAndSay(n-1); String res = \"\"; int len = preStr.length(); for(int i=0;i&lt;len;i++){ int k = i; while(i+1&lt;len&amp;&amp;preStr.charAt(i)==preStr.charAt(i+1)){ i++; } res = res+ (i-k+1) + preStr.charAt(i); } return res; }} 运行的时间和空间复杂度如下图： 总结： 终止条件写为n&lt;=1，而不是n==1可以使代码更加严谨； 在该代码之前,确定某个字符的个数所采用的方法，并不是i-k+1,而是每次遍历时，都初始化k=0,然后在while循环体中执行k++，这样做比前一种做法效率更低； 运用递归解决问题时，切忌追根到底，满足递归的构造规则，即可灵活应用 递归比较低效，还有其他方法可以代替吗？","link":"/2019/04/06/报数/"}],"tags":[{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"}]}